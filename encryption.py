import hashlib
import os
from Cryptodome.Cipher import AES
from Cryptodome.Random import get_random_bytes

import config
import test_framework
import bitcoinlib
import blockchain
import tkinter as tk
from tkinter import filedialog
from tkinter.simpledialog import askstring
from tkinter import messagebox

salt=b'bf23d8d34a3ba2d60bc4584128491331ae9b0d5822cd53388800c7af38e90e32'
#this salt was randomly generated by the programmer.
#it is combined with your password to help against rainbow attacks

wallt_file=None
passwd=None
wallet_opened=False

def create_wallet():
	f = tk.filedialog.asksaveasfile(initialdir = os.getcwd()+"/wallet_files",mode='w', defaultextension=".wallet",filetypes = (("Wallet files",
                                                        "*.wallet*"),
                                                       ("all files",
                                                        "*.*")))
	
	if f is None: # asksaveasfile return `None` if dialog closed with "cancel".
		return

	text2save = str("hallo") # starts from `1.0`, not `0.0`
	f.write(text2save)
	f.close() # `()` was missing.

def save_wallet_to_new_file():
	
	global wallt_file
	global passwd
	wallt_file = tk.filedialog.asksaveasfilename(initialdir = os.getcwd()+"/wallet_files",filetypes = (("Wallet files",
                                                        "*.wallet*"),
                                                       ("all files",
                                                        "*.*")))

	index = wallt_file.find("wallet_files/")
	wallt_name = wallt_file[index+13:]

	if wallt_name.isdigit():
		wallt_file=None
		print("Unsoppurted wallet name. Your wallet name must not contain numbers only")
		messagebox.showerror("Unsoppurted wallet name", "Your wallet name must not contain numbers only")
		return False

	if(len(wallt_file)==0):
		wallt_file=None
		messagebox.showinfo("Wallet name invalid", "You must enter a wallet name and click 'ok'.")
		return False
	
	
	if(len(wallt_file)<7):
		wallt_file+=".wallet"
	elif(wallt_file[-7:]!=".wallet"):
		wallt_file+=".wallet"

	if wallt_file is None: # asksaveasfile return `False` if dialog closed with "cancel".
		
		return False

	try:
		file_=open(wallt_file)
		file_.close()
		messagebox.showinfo("File already exists", "This wallet already exists. You can't override a wallet with a new wallet.")
		wallt_file=None
		passwd=None
		return False
	except:
		passwd=askstring("Create new wallet file","You are creating a new wallet file. Enter a strong password below",show="*")

		if(passwd ==None or len(passwd)==0):
			messagebox.showinfo("Password invalid", "You must enter a password and click 'ok'.")
			wallt_file=None
			passwd=None
			return False
			
	#save_wallet(wallet_file=wallt_file,password=passwd)
	return True


def save_wallet(promt_confirmation=False):
	
	# Try to save wallet.
	# If wallet doesn't exist, create empty wallet file at startup
	# Else fill wallet file with wallet information

	data=""

	if(wallt_file is None):
		val=save_wallet_to_new_file()
		if(val==False):return False

	else:
	
		data+="<config>"+config.gl_base_unit+"<config_end>"

		data+="<blockheight>"+str(blockchain.block_height)+"<blockheight_end>"

		data+="<publiccontainer>"
		for pubkey_container in config.gl_gui_build_address.pubkey_container_array:
			data+=str(pubkey_container.label0)
			data+="<pos>"+str(pubkey_container.x_pos)+","+str(pubkey_container.y_pos)+","
			if(pubkey_container.isMini):data+="1"
			else:data+="0"
			if(pubkey_container.ext_key is not None):
				if(pubkey_container.is_mine):
					data+="<xprv>"+str(pubkey_container.ext_key.wif(is_private=True))
				else:
					data+="<xpub>"+str(pubkey_container.ext_key.wif_public())
			elif(len(pubkey_container.parent_array)>0):
				data+="<parents>"
				for parent in pubkey_container.parent_array:
					data+=str(config.gl_gui_build_address.pubkey_container_array.index(parent))+","
			elif(len(pubkey_container.privkey)>0):
				data+="<prv>"+str(pubkey_container.privkey[0])
			elif(pubkey_container.pubkey[0] is not None):
				data+="<pub>"+str(pubkey_container.pubkey[0])
			else:
				print("ERROR IN SAVE_WALLET() public container does not have extended, priv and pub key")
			data+="<end>"
		data+="<publiccontainer_end>"

		data+="<scriptcontainer>"
		for script_container in config.gl_gui_build_address.script_container_array:
			data+=str(script_container.label0)
			data+="<pos>"+str(script_container.x_pos)+","+str(script_container.y_pos)+","
			if(script_container.isMini):data+="1"
			if(script_container.timelockDelay>0):
				data+="<rel_timelock>"+str(script_container.timelockDelay)
			if(script_container.timelock>0):
				data+="<abs_timelock>"+str(script_container.timelock)
			if(script_container.hash160 is not None):
				data+="<hash160>"+str(script_container.hash160.hex())
			if(script_container.hash160_preimage is not None):
				data+="<preimage>"+str(script_container.hash160_preimage)
			data+="<parents>"
			for parent in script_container.parent_array:
					data+=str(config.gl_gui_build_address.pubkey_container_array.index(parent))+","
			data+="<end>"
		data+="<scriptcontainer_end>"

		data+="<hashcontainer>"
		for hash_container in config.gl_gui_build_address.hash_container_array:
			data+=str(hash_container.label0)
			data+="<pos>"+str(hash_container.x_pos)+","+str(hash_container.y_pos)+","
			if(hash_container.isMini):data+="1"
			data+="<parents>"
			for parent in hash_container.parent_array:
					try:
						data+="script"+str(config.gl_gui_build_address.script_container_array.index(parent))+","
					except:
						try:
							data+="hash"+str(config.gl_gui_build_address.hash_container_array.index(parent))+","
						except:
							print("ERROR IN SAVE_WALLET! parent not found in script or hash array")
			data+="<end>"
		data+="<hashcontainer_end>"

		if(config.gl_gui_build_address.taproot_container is not None):
			taproot_container=config.gl_gui_build_address.taproot_container
			data+="<taprootcontainer>"
			data+=str(taproot_container.label0)
			data+="<pos>"+str(taproot_container.x_pos)+","+str(taproot_container.y_pos)+","
			if(taproot_container.isMini):data+="1"
			data+="<parents>"
			for parent in taproot_container.parent_array:
					try:
						data+="pub"+str(config.gl_gui_build_address.pubkey_container_array.index(parent))+","
					except:
						try:
							data+="script"+str(config.gl_gui_build_address.script_container_array.index(parent))+","
						except:
							try:
								data+="hash"+str(config.gl_gui_build_address.hash_container_array.index(parent))+","
							except:
								print("ERROR IN SAVE_WALLET! parent not found in pubkey, script or hash array")
			data+="<end>"
			data+="<taprootcontainer_end>"



	encrypt(wallt_file,data,passwd)
	if(promt_confirmation):
		messagebox.showinfo("Wallet saved", "Wallet saved successfully")

	config.gl_gui.bool_ask_for_save=False
	return True
	

	
def encrypt(file_,data,password):
	data=str.encode(data)
	password=str.encode(password)
	
	key = hashlib.scrypt(password, salt=salt, n=2**14, r=8, p=1, dklen=32)
	cipher = AES.new(key, AES.MODE_GCM)
	ciphertext, tag = cipher.encrypt_and_digest(data)

	file_= open(file_, "wb")
	[ file_.write(x) for x in (cipher.nonce, tag, ciphertext) ]
	file_.close()




def decrypt(wallet_name,password):
	file_name=str(wallet_name)
	password=str.encode(password)

	file_in = open(file_name, "rb")
	nonce, tag, ciphertext = [ file_in.read(x) for x in (16, 16, -1) ]

	key = hashlib.scrypt(password, salt=salt, n=2**14, r=8, p=1, dklen=32)
	cipher = AES.new(key, AES.MODE_GCM, nonce)
	try:
		data = cipher.decrypt_and_verify(ciphertext, tag)
		passwd=password
		return data
	except:
		return 0


def load_wallet():

	global wallt_file
	global passwd
	global wallet_opened

	wallt_file = tk.filedialog.askopenfilename(initialdir = os.getcwd()+"/wallet_files",
                                          title = "Select a File",
                                          filetypes = (("Text files",
                                                        "*.wallet*"),
                                                       ("all files",
                                                        "*.*")))

	if wallt_file.isdigit():
		print("Unsoppurted wallet name. Your wallet name must not contain numbers only")
		messagebox.showerror("Unsoppurted wallet name", "Your wallet name must not contain numbers only")
		return
	
	if(len(wallt_file) ==0): wallt_file=None; return
	passwd=askstring("Open wallet file","This file is encrypted. Enter password below",show="*")
	if(passwd is None):return

	print("Loading wallet information from "+str(wallt_file))
	

	result=decrypt(wallt_file,passwd)
	if(result==0):
		print("Wrong password")
		messagebox.showerror("Wrong password", "Your password is not correct")
		return
	data=result.decode('UTF-8')

	try:
		delete_content()
	except:
		pass
	


	config.gl_gui.create_new_wallet_page() # Load empty wallet then fill in some information in loop below

	while(len(data)>0):
		next_object_end=data.index("_end>")
		next_object=data[:next_object_end+5]
		read_next_object(next_object)
		data=data[next_object_end+5:]
		

	blockchain.update_connection_status()
	config.gl_gui.bool_ask_for_save=False
	wallet_opened=True


def read_next_object(object_):
	# read next piece of data between <type> and <type_end>
	
	index_end=object_.index(">")

	type_of_data=object_[1:index_end]
	end_of_data=object_.index(type_of_data+"_end>")
	
	data=object_[index_end+1:end_of_data-1]
		

	if(type_of_data=="config"):
		config.gl_base_unit=data

	elif(type_of_data=="blockheight"):
		print("Blockheight from cache ",data)
		if(int(data)<blockchain.block_height):
			print("Upgrading block height from ",data," to ",blockchain.block_height)
			#blockchain.block_height=int(data)

	elif(type_of_data=="publiccontainer"):
		read_all_public_container_packets(data)

	elif(type_of_data=="scriptcontainer"):
		read_all_script_container_packets(data)

	elif(type_of_data=="hashcontainer"):
		read_all_hash_container_packets(data)

	elif(type_of_data=="taprootcontainer"):
		read_taproot_container_data(data)




def read_all_public_container_packets(data):
	while(len(data)>5):
	
		index_end=data.index("<end>")
		single_container_data=data[:index_end+5]
		read_single_pubcontainer_data(single_container_data)
		data=data[index_end+5:]


def read_single_pubcontainer_data(data):
	
	index_next_end=data.index("<")
	

	label=data[:index_next_end]
	data=data[index_next_end:]

	index_next_end=data.index(",")

	x_string=data[5:index_next_end]
	data=data[index_next_end+1:]

	index_next_end=data.index(",")
	y_string=data[:index_next_end]
	data=data[index_next_end:]

	index_next_end=data.index("<")
	isMini=True if(data[1:index_next_end]=="1")else False

	data=data[index_next_end:]

	index_end=data.index("<end>")
	
	if(data[:5]=="<prv>"):
		priv_str=data[5:index_end]
		priv_hex=hex(int(priv_str))[2:]
		priv_bytes=bytes.fromhex(priv_hex)
		priv,pub=test_framework.generate_bip340_key_pair(priv_bytes)
		config.gl_gui_build_address.add_pubkey_container(label=label,ext_key=None,privKey=[priv],pubKey=[pub],parent_array=[],is_mine=True,has_extended_parent=False,x_pos=int(x_string),y_pos=int(y_string))
		
		data=data[index_end+5:]

	if(data[:5]=="<pub>"):
		pub_str=data[5:index_end]
		pub_hex=hex(int(pub_str, 16))[2:]
		pub_bytes=bytes.fromhex(pub_hex)
		pub=test_framework.ECPubKey().set(pub_bytes)
		config.gl_gui_build_address.add_pubkey_container(label=label,ext_key=None,privKey=[],pubKey=[pub],parent_array=[],is_mine=False,has_extended_parent=False,x_pos=int(x_string),y_pos=int(y_string))
		data=data[index_end+5:]

	if(data[:6]=="<xprv>"):
		xprv_string=data[6:index_end]
		hd_key=bitcoinlib.keys.HDKey().from_wif(xprv_string)
		config.gl_gui_build_address.add_pubkey_container(label=label,ext_key=hd_key,privKey=[],pubKey=[],parent_array=[],is_mine=True,has_extended_parent=False,x_pos=int(x_string),y_pos=int(y_string))
		data=data[index_end+6:]

	if(data[:6]=="<xpub>"):
		xprv_string=data[6:index_end]
		hd_key=bitcoinlib.keys.HDKey().from_wif(xprv_string)
		config.gl_gui_build_address.add_pubkey_container(label=label,ext_key=hd_key,privKey=[],pubKey=[],parent_array=[],is_mine=False,has_extended_parent=False,x_pos=int(x_string),y_pos=int(y_string))
		data=data[index_end+6:]

	if(data[:9]=="<parents>"):
		data=data[9:index_end]

		while(len(data)>1):
			index_comma=data.index(",")
			parent=int(data[:index_comma])
			data=data[index_comma+1:]
			
			config.gl_selected_container.append(config.gl_gui_build_address.pubkey_container_array[parent])

		try:
			config.gl_gui_build_address.editLabel.set(label)
		except:
			config.gl_gui_build_address.editLabel.configure(text=label)
		config.gl_gui_build_address.calc_key_released_multisig(int(float(x_string)),int(float(y_string)))

	if(isMini):config.gl_gui_build_address.pubkey_container_array[-1].minimizeContainer()


def read_all_script_container_packets(data):
	while(len(data)>5):

		index_end=data.index("<end>")
		single_container_data=data[:index_end+5]
		read_single_scriptcontainer_data(single_container_data)
		data=data[index_end+5:]



def read_single_scriptcontainer_data(data):
	index_next_end=data.index("<")
	

	label=data[:index_next_end]
	data=data[index_next_end:]

	index_next_end=data.index(",")
	x_string=data[5:index_next_end]
	data=data[index_next_end+1:]

	index_next_end=data.index(",")
	y_string=data[:index_next_end]
	data=data[index_next_end:]

	index_next_end=data.index("<")
	isMini=True if(data[1:index_next_end]=="1")else False
	data=data[index_next_end:]

	rel_timelock=0
	if(data[:14]=="<rel_timelock>"):
		data=data[14:]
		index_next_end=data.index("<")
		rel_timelock=int(data[:index_next_end])
		data=data[index_next_end:]
	abs_timelock=0
	if(data[:14]=="<abs_timelock>"):
		data=data[14:]
		index_next_end=data.index("<")
		abs_timelock=int(data[:index_next_end])
		data=data[index_next_end:]
	hash160=None
	if(data[:9]=="<hash160>"):
		data=data[9:]
		index_next_end=data.index("<")
		hash160=(data[:index_next_end])
		hash160=bytes.fromhex(hash160)
		data=data[index_next_end:]
	preimage=None
	if(data[:10]=="<preimage>"):
		data=data[10:]
		index_next_end=data.index("<")
		preimage=(data[:index_next_end])
		data=data[index_next_end:]

	if(data[:9]=="<parents>"):
		data=data[9:]
		index_end=data.index("<end>")
		data=data[:index_end]

		index_comma=data.index(",")
		parent=int(data[:index_comma])
		data=data[index_comma+1:]
		
		pubcontainer=config.gl_gui_build_address.pubkey_container_array[parent]
		pubcontainer.createScript(label=label,x_pos=int(float(x_string)),y_pos=int(float(y_string)),timelockdelay=rel_timelock,timelock=abs_timelock,hash160=hash160)

	if(isMini):config.gl_gui_build_address.script_container_array[-1].minimizeContainer()

def read_all_hash_container_packets(data):
	while(len(data)>5):

		index_end=data.index("<end>")
		single_container_data=data[:index_end+5]
		read_single_hashcontainer_data(single_container_data)
		data=data[index_end+5:]



def read_single_hashcontainer_data(data):
	index_next_end=data.index("<")
	

	label=data[:index_next_end]
	data=data[index_next_end:]

	index_next_end=data.index(",")
	x_string=data[5:index_next_end]
	data=data[index_next_end+1:]

	index_next_end=data.index(",")
	y_string=data[:index_next_end]
	data=data[index_next_end:]

	index_next_end=data.index("<")
	isMini=True if(data[1:index_next_end]=="1")else False
	data=data[index_next_end:]


	if(data[:9]=="<parents>"):
		index_end=data.index("<end>")
		data=data[9:index_end]
		
		while(len(data)>1):

			index_comma=data.index(",")
			parent_string=data[:index_comma]
			if(parent_string[:4]=="hash"):
				parent_index=int(parent_string[4:])
				hash_container_parent=config.gl_gui_build_address.hash_container_array[parent_index]
				config.gl_selected_container.append(hash_container_parent)
			elif(parent_string[:6]=="script"):
				parent_index=int(parent_string[6:])
				script_container_parent=config.gl_gui_build_address.script_container_array[parent_index]
				config.gl_selected_container.append(script_container_parent)

			data=data[index_comma+1:]
		
		config.gl_gui_build_address.calc_key_released_tapbranch(int(float(x_string)),int(float(y_string)))

	if(isMini):config.gl_gui_build_address.hash_container_array[-1].minimizeContainer()


def read_taproot_container_data(data):
	index_next_end=data.index("<")
	
	label=data[:index_next_end]
	data=data[index_next_end:]

	index_next_end=data.index(",")
	x_string=data[5:index_next_end]
	data=data[index_next_end+1:]

	index_next_end=data.index(",")
	y_string=data[:index_next_end]
	data=data[index_next_end:]

	index_next_end=data.index("<")
	isMini=True if(data[1:index_next_end]=="1")else False
	data=data[index_next_end:]


	if(data[:9]=="<parents>"):
		index_end=data.index("<end>")
		data=data[9:index_end]
		
		while(len(data)>1):

			index_comma=data.index(",")
			parent_string=data[:index_comma]
			if(parent_string[:3]=="pub"):
				parent_index=int(parent_string[3:])
				pub_container_parent=config.gl_gui_build_address.pubkey_container_array[parent_index]
				config.gl_selected_container.append(pub_container_parent)
			elif(parent_string[:4]=="hash"):
				parent_index=int(parent_string[4:])
				hash_container_parent=config.gl_gui_build_address.hash_container_array[parent_index]
				config.gl_selected_container.append(hash_container_parent)
			elif(parent_string[:6]=="script"):
				parent_index=int(parent_string[6:])
				script_container_parent=config.gl_gui_build_address.script_container_array[parent_index]
				config.gl_selected_container.append(script_container_parent)

			data=data[index_comma+1:]
		
	config.gl_gui_build_address.calc_key_released_taproot(0,int(float(x_string)),int(float(50)))
	if(isMini):config.gl_gui_build_address.taproot_container.minimizeContainer()

def delete_content():
	length=len(config.gl_gui_build_address.pubkey_container_array)

	for i in range(length):
		if(len(config.gl_gui_build_address.pubkey_container_array)>0):
			config.gl_gui_build_address.pubkey_container_array[0].remove_container()

	config.gl_gui_build_address.make_new()
